package orders

import (
	"client/api"
	"client/internal/domain/offers"
	"client/internal/external"
	"context"
	"errors"
	"fmt"
	"math"
	"time"
)

var (
	// ErrOfferNotFound is returned when offer doesn't exist
	ErrOfferNotFound = errors.New("offer not found")
	// ErrOfferExpired is returned when offer has expired
	ErrOfferExpired = errors.New("offer expired")
	// ErrOfferAlreadyUsed is returned when offer was already used
	ErrOfferAlreadyUsed = errors.New("offer already used")
	// ErrInvalidUser is returned when user_id doesn't match offer's user_id
	ErrInvalidUser = errors.New("user_id doesn't match offer")
	// ErrOrderAlreadyExists is returned when order with same offer_id already exists (idempotency)
	ErrOrderAlreadyExists = errors.New("order already exists for this offer")

	// ErrNoSuchOrder is returned when order id not found
	ErrNoSuchOrder = errors.New("order not found")
	// ErrOrderNotActive is returned when finishing non-active order (idempotency signal)
	ErrOrderNotActive = errors.New("order not active")
)

// OrderCache is a small interface for Redis-based order cache
// Implementations should store serialized Order with TTL and provide invalidation.
type OrderCache interface {
	GetOrder(ctx context.Context, orderID string) (*api.Order, error)
	SetOrder(ctx context.Context, order *api.Order, ttl time.Duration) error
	Invalidate(ctx context.Context, orderID string) error
}

// ServiceInterface defines the interface for order service operations
type ServiceInterface interface {
	CreateOrder(ctx context.Context, req *CreateOrderRequest) (*api.Order, error)
	GetOrder(ctx context.Context, orderID string) (*api.Order, error)
	FinishOrder(ctx context.Context, orderID string) (*api.Order, error)
}

// Service handles business logic for orders
type Service struct {
	orderRepo      Repository
	offerRepo      offers.Repository
	paymentsClient external.PaymentsClientInterface
	cache          OrderCache
}

// NewService creates a new orders service (without cache)
func NewService(orderRepo Repository, offerRepo offers.Repository, paymentsClient external.PaymentsClientInterface) *Service {
	return NewServiceWithCache(orderRepo, offerRepo, paymentsClient, nil)
}

// NewServiceWithCache creates a new orders service with an optional Redis cache
func NewServiceWithCache(orderRepo Repository, offerRepo offers.Repository, paymentsClient external.PaymentsClientInterface, cache OrderCache) *Service {
	return &Service{
		orderRepo:      orderRepo,
		offerRepo:      offerRepo,
		paymentsClient: paymentsClient,
		cache:          cache,
	}
}

// CreateOrderRequest represents the input for creating an order (ADR: client-provided order_id for idempotency)
type CreateOrderRequest struct {
	OrderID string
	OfferID string
	UserID  string
}

// CreateOrder creates a new order from an offer
// According to ADR:
// 1. Validate offer (not expired, not used)
// 2. If valid, hold deposit on user's card
// 3. Create order
// 4. Ensure idempotency (if order already exists for this offer, return existing)
func (s *Service) CreateOrder(ctx context.Context, req *CreateOrderRequest) (*api.Order, error) {
	// Step 1: Idempotency by client-provided order_id (ADR)
	if req.OrderID == "" {
		return nil, fmt.Errorf("order_id is required")
	}
	existingOrder, err := s.orderRepo.GetOrderByID(ctx, req.OrderID)
	if err != nil {
		return nil, fmt.Errorf("failed to check existing order: %w", err)
	}
	if existingOrder != nil {
		return existingOrder, nil
	}

	// Step 2: Get and validate offer
	offer, err := s.offerRepo.GetOffer(ctx, req.OfferID)
	if err != nil {
		return nil, fmt.Errorf("failed to get offer: %w", err)
	}
	if offer == nil {
		return nil, ErrOfferNotFound
	}

	// Step 3: Validate offer is not expired
	if time.Now().After(offer.ExpiresAt) {
		return nil, ErrOfferExpired
	}

	// Step 4: Validate user_id matches
	if offer.UserId != req.UserID {
		return nil, ErrInvalidUser
	}

	// Step 5: Try to mark offer as used (atomic operation)
	marked, err := s.offerRepo.MarkOfferAsUsed(ctx, req.OfferID)
	if err != nil {
		return nil, fmt.Errorf("failed to mark offer as used: %w", err)
	}
	if !marked {
		// Offer was already used by another request
		return nil, ErrOfferAlreadyUsed
	}

	// Step 6: Use client-provided order ID (UUID generated by client)
	orderID := req.OrderID

	// Step 7: Hold deposit on user's card
	holdReq := &external.PaymentHoldRequest{
		UserID:  req.UserID,
		OrderID: orderID,
		Amount:  offer.Deposit,
	}
	holdResp, err := s.paymentsClient.HoldMoneyForOrder(ctx, holdReq)
	if err != nil {
		// If payment hold fails, we should not create the order
		// Note: In production, we might want to retry or handle this differently
		return nil, fmt.Errorf("failed to hold deposit: %w", err)
	}
	if !holdResp.Success {
		return nil, fmt.Errorf("payment hold failed")
	}

	// Step 8: Create order
	now := time.Now()
	order := &api.Order{
		Id:             orderID,
		OfferId:        req.OfferID,
		UserId:         req.UserID,
		ScooterId:      offer.ScooterId,
		Status:         api.ACTIVE,
		StartTime:      now,
		PricePerMinute: &offer.PricePerMinute,
		PriceUnlock:    &offer.PriceUnlock,
		Deposit:        &offer.Deposit,
		CurrentAmount:  &offer.PriceUnlock, // Initial amount includes unlock price
	}

	// Step 9: Save order to database with payment transaction
	// According to ADR, this should be in a transaction with payment transaction record
	if err := s.orderRepo.CreateOrder(ctx, order, holdResp.TransactionID); err != nil {
		// If order creation fails, we should unhold the deposit
		// In production, this should be handled in a transaction
		_ = s.paymentsClient.UnholdMoneyForOrder(ctx, orderID)
		return nil, fmt.Errorf("failed to create order: %w", err)
	}

	// Step 10: Write-through to cache (TTL 30 minutes)
	if s.cache != nil {
		_ = s.cache.SetOrder(ctx, order, 30*time.Minute)
	}

	return order, nil
}

// GetOrder returns order info with cache-first lookup and DB fallback
func (s *Service) GetOrder(ctx context.Context, orderID string) (*api.Order, error) {
	if orderID == "" {
		return nil, fmt.Errorf("order_id is required")
	}

	// Try cache
	if s.cache != nil {
		if cached, err := s.cache.GetOrder(ctx, orderID); err == nil && cached != nil {
			return cached, nil
		}
		// ignore cache errors; fallback to DB
	}

	// Fallback to DB
	order, err := s.orderRepo.GetOrderByID(ctx, orderID)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}
	if order == nil {
		return nil, nil
	}

	// Populate cache
	if s.cache != nil {
		_ = s.cache.SetOrder(ctx, order, 30*time.Minute)
	}

	return order, nil
}

// FinishOrder finalizes an active order:
// - idempotent: if order not ACTIVE, returns current order with ErrOrderNotActive
// - calculates duration and total (unlock + ceil(seconds/60)*ppm)
// - charges amount and unholds deposit (if charge succeeded)
// - persists results and payment transactions via repository
// - invalidates and refreshes cache
func (s *Service) FinishOrder(ctx context.Context, orderID string) (*api.Order, error) {
	// Load order
	order, err := s.orderRepo.GetOrderByID(ctx, orderID)
	if err != nil {
		return nil, fmt.Errorf("failed to get order: %w", err)
	}
	if order == nil {
		return nil, ErrNoSuchOrder
	}
	if order.Status != api.ACTIVE {
		// Idempotent finish
		return order, ErrOrderNotActive
	}

	// Compute duration and total
	now := time.Now()
	durationSeconds := int(now.Sub(order.StartTime).Seconds())
	if durationSeconds < 0 {
		durationSeconds = 0
	}

	ppm := 0
	if order.PricePerMinute != nil {
		ppm = *order.PricePerMinute
	}
	unlock := 0
	if order.PriceUnlock != nil {
		unlock = *order.PriceUnlock
	}
	minutes := int(math.Ceil(float64(durationSeconds) / 60.0))
	usage := minutes * ppm
	total := unlock + usage

	// Charge
	chargeErr := s.paymentsClient.ChargeMoneyForOrder(ctx, orderID, total)
	chargeSuccess := chargeErr == nil

	// Unhold (only if charge succeeded)
	unholdSuccess := false
	if chargeSuccess {
		if err := s.paymentsClient.UnholdMoneyForOrder(ctx, orderID); err == nil {
			unholdSuccess = true
		}
	}

	finalStatus := api.FINISHED
	if !chargeSuccess {
		finalStatus = api.PAYMENTFAILED
	}

	// Persist result
	if err := s.orderRepo.FinishOrder(ctx, orderID, now, durationSeconds, total, finalStatus, chargeSuccess, unholdSuccess, ""); err != nil {
		return nil, fmt.Errorf("failed to finish order: %w", err)
	}

	// Invalidate cache
	if s.cache != nil {
		_ = s.cache.Invalidate(ctx, orderID)
	}

	// Return updated order
	updated, err := s.orderRepo.GetOrderByID(ctx, orderID)
	if err != nil {
		return nil, fmt.Errorf("failed to reload order: %w", err)
	}
	if s.cache != nil && updated != nil {
		_ = s.cache.SetOrder(ctx, updated, 30*time.Minute)
	}
	return updated, nil
}
